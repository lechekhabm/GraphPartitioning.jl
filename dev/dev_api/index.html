<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Developers API Reference · GraphLab.jl</title><meta name="title" content="Developers API Reference · GraphLab.jl"/><meta property="og:title" content="Developers API Reference · GraphLab.jl"/><meta property="twitter:title" content="Developers API Reference · GraphLab.jl"/><meta name="description" content="Documentation for GraphLab.jl."/><meta property="og:description" content="Documentation for GraphLab.jl."/><meta property="twitter:description" content="Documentation for GraphLab.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="GraphLab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GraphLab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../usage/">Usage Guide</a></li><li><a class="tocitem" href="../api/">API Reference</a></li><li class="is-active"><a class="tocitem" href>Developers API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Developers API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Developers API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lechekhabm/GraphLab.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lechekhabm/GraphLab.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Developers-API-Reference"><a class="docs-heading-anchor" href="#Developers-API-Reference">Developers API Reference</a><a id="Developers-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Developers-API-Reference" title="Permalink"></a></h1><p>This section lists the public and private functions exported by <code>GraphLab.jl</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.KdNode" href="#GraphLab.KdNode"><code>GraphLab.KdNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KdNode</code></pre><p>A node in a 2D kd-tree data structure, representing a spatial region and its recursive subdivision.</p><p>Each node contains bounding box coordinates, optional _splitting information, and links to child nodes. The node can also store associated data points and optional entry/exit traversal symbols for space-filling curve traversal.</p><p><strong>Fields</strong></p><ul><li><code>bbox::Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}</code>: Bounding box as <code>(min_coords, max_coords)</code>.</li><li><code>_splitdim::Union{Int, Nothing}</code>: _splitting dimension (1 for x-axis, 2 for y-axis), or <code>nothing</code> for leaf.</li><li><code>_splitval::Union{Float64, Nothing}</code>: Coordinate value of the _splitting plane, or <code>nothing</code> for leaf.</li><li><code>left::Union{KdNode, Nothing}</code>: Left child node (subtree with coordinates ≤ <code>_splitval</code>), or <code>nothing</code>.</li><li><code>right::Union{KdNode, Nothing}</code>: Right child node (subtree with coordinates &gt; <code>_splitval</code>), or <code>nothing</code>.</li><li><code>is_leaf::Bool</code>: Whether the node is a leaf.</li><li><code>is_root::Bool</code>: Whether the node is the root of the tree.</li><li><code>data::Matrix{Float64}</code>: Data points contained in this node.</li><li><code>entry::Union{Symbol, Nothing}</code>: Optional entry symbol for space-filling curve traversal.</li><li><code>exit::Union{Symbol, Nothing}</code>: Optional exit symbol for space-filling curve traversal.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._append_gilbert!-Tuple{Vector{CartesianIndex{2}}, AbstractMatrix}" href="#GraphLab._append_gilbert!-Tuple{Vector{CartesianIndex{2}}, AbstractMatrix}"><code>GraphLab._append_gilbert!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_append_gilbert!(path, grid::AbstractMatrix)</code></pre><p>Recursively traverse the given matrix <code>grid</code> using a generalized Gilbert curve pattern. Appends the <code>CartesianIndex</code> entries to <code>path</code> in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._bbox_center-Tuple{Any}" href="#GraphLab._bbox_center-Tuple{Any}"><code>GraphLab._bbox_center</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_bbox_center(bbox)</code></pre><p>Compute the center point of a bounding box.</p><p><strong>Arguments</strong></p><ul><li><code>bbox</code>: A tuple <code>((xmin, ymin), (xmax, ymax))</code> representing the bounding box corners.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple <code>(xcenter, ycenter)</code> representing the center coordinates of the bounding box.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; _bbox_center(((0.0, 0.0), (2.0, 4.0)))
(1.0, 2.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._bounding_box-Tuple{Matrix{Float64}}" href="#GraphLab._bounding_box-Tuple{Matrix{Float64}}"><code>GraphLab._bounding_box</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_bounding_box(coords::Matrix{Float64})</code></pre><p>Compute the axis-aligned bounding box for a set of 2D points.</p><p><strong>Arguments</strong></p><ul><li><code>coords::Matrix{Float64}</code>: A matrix of size <code>n × 2</code>, where each row represents a 2D point <code>(x, y)</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple <code>((xmin, ymin), (xmax, ymax))</code> representing the lower-left and upper-right corners of the bounding box.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; _bounding_box([1.0 2.0; 3.0 4.0; -1.0 5.0])
((-1.0, 2.0), (3.0, 5.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._build_tree" href="#GraphLab._build_tree"><code>GraphLab._build_tree</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_build_tree(coords::Matrix{Float64}, is_root::Bool=true)</code></pre><p>Recursively build a 2D kd-tree from a set of points. Leaf nodes contain the data points inside their region.</p><p><strong>Arguments</strong></p><ul><li><code>coords::Matrix{Float64}</code>: A matrix of size <code>n × 2</code>, where each row is a 2D point <code>(x, y)</code>.</li><li><code>is_root::Bool=true</code>: Whether this node is the root of the tree (automatically set during recursion).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>KdNode</code> representing the root of the kd-tree.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tree = _build_tree([1.0 2.0; 3.0 4.0; 0.0 5.0])
KdNode(...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._centerpoint-Tuple{Matrix{Float64}, Int64}" href="#GraphLab._centerpoint-Tuple{Matrix{Float64}, Int64}"><code>GraphLab._centerpoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Approximate _centerpoint by coordinate-wise median of a random sample.</p><p>Arguments:</p><ul><li>X::Matrix{Float64}: n × d data matrix</li><li>sample_size::Int: number of random rows to sample</li></ul><p>Returns:</p><ul><li>center::Vector{Float64}: estimated _centerpoint</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._conmap-Tuple{Vector{Float64}, Matrix{Float64}}" href="#GraphLab._conmap-Tuple{Vector{Float64}, Matrix{Float64}}"><code>GraphLab._conmap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Conformal map that moves <code>center</code> to the origin on the unit sphere.</p><p>Arguments:</p><ul><li>center::Vector{Float64}: _centerpoint on the sphere (length d+1)</li><li>X::Matrix{Float64}: n × (d+1) matrix of lifted points</li></ul><p>Returns:</p><ul><li>Y::Matrix{Float64}: transformed points (same size as X)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._get_alignment-Tuple{Symbol, Int64}" href="#GraphLab._get_alignment-Tuple{Symbol, Int64}"><code>GraphLab._get_alignment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_alignment(entry::Symbol, _splitdim::Int)</code></pre><p>Determine the alignment of an entry direction relative to the _splitting dimension.</p><p><strong>Arguments</strong></p><ul><li><code>entry::Symbol</code>: Entry direction (<code>:L</code>, <code>:R</code>, <code>:T</code>, or <code>:B</code>).</li><li><code>_splitdim::Int</code>: _splitting dimension (<code>1</code> for x-axis, <code>2</code> for y-axis).</li></ul><p><strong>Returns</strong></p><ul><li><code>:parallel</code> if entry edge direction is parallel to the _splitting dimension.</li><li><code>:perpendicular</code> otherwise.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; _get_alignment(:L, 1)
:parallel
julia&gt; _get_alignment(:T, 1)
:perpendicular</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._get_child-Tuple{GraphLab.KdNode, Symbol}" href="#GraphLab._get_child-Tuple{GraphLab.KdNode, Symbol}"><code>GraphLab._get_child</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_child(node::KdNode, side::Symbol)</code></pre><p>Return the child node of a <code>KdNode</code> corresponding to the specified side.</p><p>This function retrieves either the left or right child node depending on the side and the _splitting dimension.</p><p><strong>Arguments</strong></p><ul><li><code>node::KdNode</code>: The kd-tree node.</li><li><code>side::Symbol</code>: Side indicator (<code>:left</code>, <code>:right</code>, <code>:bottom</code>, or <code>:top</code>).</li></ul><p><strong>Returns</strong></p><ul><li>The child <code>KdNode</code> corresponding to the requested side.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; _get_child(node, :left)
KdNode(...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._get_child_entry_exit-Tuple{Symbol, Symbol, Int64, Symbol}" href="#GraphLab._get_child_entry_exit-Tuple{Symbol, Symbol, Int64, Symbol}"><code>GraphLab._get_child_entry_exit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_child_entry_exit(parent_entry::Symbol, parent_exit::Symbol, _splitdim::Int, side::Symbol)</code></pre><p>Compute the entry and exit directions for a child node in a kd-tree traversal.</p><p>Given the parent node’s entry and exit directions, the _splitting dimension, and the side being traversed, this function determines the entry and exit directions for the child node according to space-filling curve traversal rules (using <code>:cis</code> and <code>:tran</code> order types and <code>:parallel</code> / <code>:perpendicular</code> alignment).</p><p><strong>Arguments</strong></p><ul><li><code>parent_entry::Symbol</code>: Entry direction at the parent node (<code>:L</code>, <code>:R</code>, <code>:T</code>, <code>:B</code>).</li><li><code>parent_exit::Symbol</code>: Exit direction at the parent node (<code>:L</code>, <code>:R</code>, <code>:T</code>, <code>:B</code>).</li><li><code>_splitdim::Int</code>: _splitting dimension (<code>1</code> for x-axis, <code>2</code> for y-axis).</li><li><code>side::Symbol</code>: Side of the child being traversed (<code>:left</code>, <code>:right</code>, <code>:top</code>, <code>:bottom</code>).</li></ul><p><strong>Returns</strong></p><ul><li>A tuple <code>(child_entry, child_exit)</code> indicating the entry and exit directions for the child node.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; _get_child_entry_exit(:L, :R, 1, :left)
(:L, :R)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._get_maximum_matching-Tuple{Graphs.SimpleGraphs.SimpleGraph}" href="#GraphLab._get_maximum_matching-Tuple{Graphs.SimpleGraphs.SimpleGraph}"><code>GraphLab._get_maximum_matching</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_maximum_matching(g::Graph)</code></pre><p>Computes a maximum weight matching of the graph <code>g</code> using a silent CBC solver.</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code>: The input graph.</li></ul><p><strong>Returns</strong></p><ul><li><code>match</code>: The matching object containing mate assignments and total weight.</li></ul><p><strong>Notes</strong></p><ul><li>Assumes unit weights unless otherwise specified.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._get_partition-Tuple{AbstractVector, Int64}" href="#GraphLab._get_partition-Tuple{AbstractVector, Int64}"><code>GraphLab._get_partition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_partition(v::AbstractVector, k::Int)</code></pre><p>Create a partition indicator vector by dividing indices into <code>k</code> contiguous groups.</p><p>This function assigns partition labels <code>1</code> to <code>k</code> to the indices in <code>v</code>, distributing them evenly into <code>k</code> partitions based on their position in <code>v</code>. Each value in <code>v</code> is assumed to be a node ID (1-based indexing), and the result maps each node ID to its partition.</p><p><strong>Arguments</strong></p><ul><li><code>v::AbstractVector</code>: A vector of node IDs to partition.</li><li><code>k::Int</code>: The number of partitions.</li></ul><p><strong>Returns</strong></p><ul><li>A vector <code>part</code> of length <code>maximum(v)</code> where <code>part[id]</code> is the partition label (1 to <code>k</code>) assigned to node <code>id</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; _get_partition([1, 2, 3, 4, 5, 6], 2)
[1, 1, 1, 2, 2, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._gilbert_indices-Tuple{Tuple{Int64, Int64}}" href="#GraphLab._gilbert_indices-Tuple{Tuple{Int64, Int64}}"><code>GraphLab._gilbert_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_gilbert_indices(grid_dims::Tuple{Int, Int}; maj_axis=grid_dims[1] ≥ grid_dims[2] ? 1 : 2)</code></pre><p>Generate a list of <code>CartesianIndex{2}</code> representing a generalized space-filling traversal of a grid with dimensions <code>grid_dims</code>, using a Gilbert-like curve. Traversal will favor rows (X axis) if <code>maj_axis == 1</code>, or columns (Y axis) if <code>maj_axis == 2</code>.</p><p><strong>Arguments</strong></p><ul><li><code>grid_dims::Tuple{Int, Int}</code>: a tuple <code>(rows, cols)</code> specifying grid size.</li><li><code>maj_axis</code>: optional; either <code>1</code> (row-major preference) or <code>2</code> (column-major preference).<ul><li>The curve will traverse more linearly along the <code>maj_axis</code>.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>A <code>Vector{CartesianIndex{2}}</code> representing the traversal path.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; order = _gilbert_indices((4, 5))
julia&gt; println(order)
[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(2, 2), ...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._gilbert_order-Tuple{AbstractMatrix}" href="#GraphLab._gilbert_order-Tuple{AbstractMatrix}"><code>GraphLab._gilbert_order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_gilbert_order(grid_indices::AbstractMatrix; maj_axis=rows ≥ cols ? 1 : 2)</code></pre><p>Return a list of <code>CartesianIndex</code> values from a grid, traversed recursively using Gilbert curve logic. When <code>maj_axis == 2</code>, the grid is transposed to preserve logic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._morton_index-Tuple{Int64, Int64}" href="#GraphLab._morton_index-Tuple{Int64, Int64}"><code>GraphLab._morton_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_morton_index(x::Int, y::Int)</code></pre><p>Interleave the bits of x and y to produce a Morton code (Z-order curve).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._morton_indices-Tuple{Tuple{Int64, Int64}}" href="#GraphLab._morton_indices-Tuple{Tuple{Int64, Int64}}"><code>GraphLab._morton_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_morton_indices(grid_dims::Tuple{Int, Int})</code></pre><p>Return a list of <code>CartesianIndex{2}</code> grid coordinates ordered by 2D Morton (Z-order) curve.</p><p><strong>Arguments</strong></p><ul><li><code>grid_dims::Tuple{Int, Int}</code>: the number of rows and columns of the grid, e.g. <code>(64, 64)</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of <code>CartesianIndex{2}</code> objects representing the traversal order.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; order = _morton_indices((4, 4))
julia&gt; println(order)
[CartesianIndex(1, 1), CartesianIndex(1, 2), CartesianIndex(2, 1), CartesianIndex(2, 2), ...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._nested_dissection-Tuple{SparseArrays.SparseMatrixCSC, Function}" href="#GraphLab._nested_dissection-Tuple{SparseArrays.SparseMatrixCSC, Function}"><code>GraphLab._nested_dissection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_nested_dissection(A::SparseMatrixCSC, method::Function; coords=nothing, minsep, verbose)</code></pre><p>Recursively computes a nested dissection ordering of a sparse matrix, handling disconnected components separately.</p><p><strong>Arguments</strong></p><ul><li><code>A::SparseMatrixCSC</code>: The adjacency matrix of the graph to partition.</li><li><code>method::Function</code>: Function used to compute separators.</li><li><code>coords::Union{Matrix, Nothing}</code>: Optional node coordinates if the separator method needs them.</li><li><code>minsep::Int</code>: Minimum number of nodes to stop recursion.</li><li><code>verbose::Bool</code>: Whether to visualize partitions and wait for user input during recursion.</li></ul><p><strong>Returns</strong></p><ul><li><code>perm::Vector{Int}</code>: The final permutation vector.</li></ul><p><strong>Notes</strong></p><ul><li>Uses approximate minimum degree ordering for small components.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._opposite_dir-Tuple{Symbol}" href="#GraphLab._opposite_dir-Tuple{Symbol}"><code>GraphLab._opposite_dir</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_opposite_dir(dir::Symbol)::Symbol</code></pre><p>Return the opposite direction symbol.</p><p><strong>Arguments</strong></p><ul><li><code>dir::Symbol</code>: Direction symbol (<code>:L</code>, <code>:R</code>, <code>:T</code>, or <code>:B</code>).</li></ul><p><strong>Returns</strong></p><ul><li>The opposite direction symbol.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; _opposite_dir(:L)
:R
julia&gt; _opposite_dir(:T)
:B</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._order_type-Tuple{Symbol, Symbol}" href="#GraphLab._order_type-Tuple{Symbol, Symbol}"><code>GraphLab._order_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_order_type(entry::Symbol, exit::Symbol)</code></pre><p>Determine the traversal type based on entry and exit directions.</p><p><strong>Arguments</strong></p><ul><li><code>entry::Symbol</code>: Entry direction (<code>:L</code>, <code>:R</code>, <code>:T</code>, or <code>:B</code>).</li><li><code>exit::Symbol</code>: Exit direction (<code>:L</code>, <code>:R</code>, <code>:T</code>, or <code>:B</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>:tran</code> if entry and exit are opposite directions.</li><li><code>:cis</code> otherwise.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; _order_type(:L, :R)
:tran
julia&gt; _order_type(:T, :R)
:cis</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._part1by1-Tuple{Int64}" href="#GraphLab._part1by1-Tuple{Int64}"><code>GraphLab._part1by1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_part1by1(n::Int)</code></pre><p>Expand 16-bit integer <code>n</code> into 32 bits with zeros between the original bits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._partition-Tuple{Matrix, Vector}" href="#GraphLab._partition-Tuple{Matrix, Vector}"><code>GraphLab._partition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_partition(coords::Matrix, v::Vector)</code></pre><p>Compute a partition based on <code>coords</code> using a direction vector <code>v</code>.</p><p><strong>Arguments</strong></p><ul><li><code>coords::Matrix</code>: Node coordinates in a 2D space.</li><li><code>v::Vector</code>: Direction vector defining the partitioning line.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple of two vectors: indices of nodes in each partition.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; _partition(coords, [0, 1])
([1, 2, 3, 9, 10], [4, 5, 6, 7, 8])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._partition-Tuple{Matrix{Float64}, Vector{Float64}}" href="#GraphLab._partition-Tuple{Matrix{Float64}, Vector{Float64}}"><code>GraphLab._partition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_partition(X, direction)</code></pre><p>Splits a set of points into two parts by projecting them onto a given direction vector and _partitioning at the median projection value.</p><p><strong>Arguments</strong></p><ul><li><code>X::Matrix{Float64}</code>: An <code>n × d</code> matrix of points (each row is a point in ℝ^d or ℝ^{d+1}).</li><li><code>direction::Vector{Float64}</code>: A direction vector along which to project the points.</li></ul><p><strong>Returns</strong></p><ul><li><code>part1::Vector{Int}</code>: Indices of points with projection ≤ median (one side of the cut).</li><li><code>part2::Vector{Int}</code>: Indices of points with projection &gt; median (the other side).</li></ul><p><strong>Notes</strong></p><ul><li>This ensures a balanced _partition by cutting at the median of the projected values.</li><li>Commonly used to implement great-circle or hyperplane separators.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._recursive_bisection" href="#GraphLab._recursive_bisection"><code>GraphLab._recursive_bisection</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_recursive_bisection(method::Function, levels::Int, A::AbstractSparseMatrix, 
                     coords::Union{Matrix, Nothing}=nothing, minpoints::Int=8, 
                     vn::Vector{Int}=Int[])</code></pre><p>Recursively partition the graph <code>A</code> using the given partitioning <code>method</code>, applying hierarchical bisection.</p><p><strong>Arguments</strong></p><ul><li><code>method::Function</code>: Partitioning method to apply (e.g., <code>part_spectral</code>, <code>part_inertial</code>).</li><li><code>levels::Int</code>: Number of recursive partitioning levels.</li><li><code>A::AbstractSparseMatrix</code>: Adjacency matrix of the graph.</li><li><code>coords::Union{Matrix, Nothing}=nothing</code>: Node coordinates for spatial partitioning (if applicable).</li><li><code>minpoints::Int=8</code>: Minimum number of nodes required to continue partitioning.</li><li><code>vn::Vector{Int}=Int[]</code>: Vector of node indices, used for tracking original node ordering.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of partition labels for each node, recursively refined through hierarchical bisection.</li></ul><p><strong>Example</strong></p><p><code>julia-repl julia&gt; _recursive_bisection(part_spectral, 3, A, coords)  1  ⋮  4</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._reflector-Tuple{Any}" href="#GraphLab._reflector-Tuple{Any}"><code>GraphLab._reflector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_reflector(c::AbstractVector)</code></pre><p>Constructs a Householder reflection matrix <code>Q</code> that maps the input vector <code>c</code> (reversed) to a multiple of the first basis vector. This is useful for aligning a given direction with a coordinate axis in geometric transformations.</p><p><strong>Arguments</strong></p><ul><li><code>c::AbstractVector</code>: A real vector of length <code>d</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Q::Matrix{Float64}</code>: A <code>d × d</code> orthogonal matrix representing the Householder reflection.</li><li><code>r::Float64</code>: The leading entry of the reflected vector (i.e., norm or signed component).</li></ul><p><strong>Notes</strong></p><ul><li>Internally, this performs a QR decomposition of the reversed vector <code>c[end:-1:1]</code> and adjusts the result to restore the original ordering.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._sepcircle-Tuple{SparseArrays.SparseMatrixCSC, Matrix{Float64}, Int64}" href="#GraphLab._sepcircle-Tuple{SparseArrays.SparseMatrixCSC, Matrix{Float64}, Int64}"><code>GraphLab._sepcircle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>_sepcircle(A::SparseMatrixCSC, X::Matrix{Float64}, ntrials::Int)</p><p>Try ntrials random great circle cuts on unit-sphere data.</p><p>Arguments:</p><ul><li>A::SparseMatrixCSC: adjacency matrix</li><li>X::Matrix{Float64}: n × (d+1) unit-sphere coordinates</li><li>ntrials::Int: number of random directions to try</li></ul><p>Returns:</p><ul><li>bestdir::Vector{Float64}: direction vector of best cut</li><li>mincut::Float64: minimum edge cut found</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._sepline-Tuple{SparseArrays.SparseMatrixCSC, Matrix{Float64}, Int64}" href="#GraphLab._sepline-Tuple{SparseArrays.SparseMatrixCSC, Matrix{Float64}, Int64}"><code>GraphLab._sepline</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>_sepline(A, xy, ntrials)</p><p>Try ntrials random straight hyperplanes in Euclidean space.</p><p>Arguments:</p><ul><li>A::SparseMatrixCSC: adjacency matrix</li><li>coords::Matrix{Float64}: n × d original coordinates</li><li>ntrials::Int: number of directions to try</li></ul><p>Returns:</p><ul><li>bestdir::Vector{Float64}: best direction</li><li>mincut::Float64: corresponding edge cut</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._sepquality-Tuple{Vector{Float64}, SparseArrays.SparseMatrixCSC, Matrix{Float64}}" href="#GraphLab._sepquality-Tuple{Vector{Float64}, SparseArrays.SparseMatrixCSC, Matrix{Float64}}"><code>GraphLab._sepquality</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_sepquality(v, A, xyz)</code></pre><p>Evaluates the quality of a geometric separator defined by a direction vector <code>v</code>, by computing the number of graph edges cut by the resulting _partition.</p><p><strong>Arguments</strong></p><ul><li><code>v::Vector{Float64}</code>: A direction vector defining the separating hyperplane (e.g., great circle).</li><li><code>A::SparseMatrixCSC</code>: The adjacency matrix of the (undirected) graph.</li><li><code>xyz::Matrix{Float64}</code>: An <code>n × (d+1)</code> matrix of vertex coordinates on the unit sphere (in ℝ^{d+1}).</li></ul><p><strong>Returns</strong></p><ul><li><code>cutsize::Int</code>: The number of edges crossing between the two sides of the _partition.</li></ul><p><strong>Notes</strong></p><ul><li>Vertices are _partitioned based on the sign of their projection onto <code>v</code>.</li><li>The number of crossing edges is computed using nonzero entries in <code>A[a, b]</code> and <code>A[b, a]&#39;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._split-Tuple{Matrix{Float64}, Int64}" href="#GraphLab._split-Tuple{Matrix{Float64}, Int64}"><code>GraphLab._split</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_split(coords::Matrix{Float64}, dim::Int)</code></pre><p>_split a set of 2D points along a specified dimension at the median.</p><p><strong>Arguments</strong></p><ul><li><code>coords::Matrix{Float64}</code>: A matrix of size <code>n × 2</code>, where each row is a 2D point <code>(x, y)</code>.</li><li><code>dim::Int</code>: _splitting dimension (<code>1</code> for x-axis, <code>2</code> for y-axis).</li></ul><p><strong>Returns</strong></p><ul><li><code>left::Matrix{Float64}</code>: Points in the left subset (≤ _split value).</li><li><code>right::Matrix{Float64}</code>: Points in the right subset (&gt; _split value).</li><li><code>_splitval::Float64</code>: The coordinate value at which the _split occurs.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; left, right, _splitval = _split([1.0 2.0; 3.0 4.0; 0.0 5.0], 1)
([0.0 5.0; 1.0 2.0], [3.0 4.0], 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._step-Tuple{Symbol, Symbol, Int64, Tuple{Float64, Float64}, Float64}" href="#GraphLab._step-Tuple{Symbol, Symbol, Int64, Tuple{Float64, Float64}, Float64}"><code>GraphLab._step</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_step(entry::Symbol, exit::Symbol, _splitdim::Int, entry_pt::Tuple{Float64, Float64}, _splitval::Float64)</code></pre><p>Determine the traversal order of child nodes in a kd-tree based on entry and exit directions.</p><p><strong>Arguments</strong></p><ul><li><code>entry::Symbol</code>: Entry direction (<code>:L</code>, <code>:R</code>, <code>:T</code>, or <code>:B</code>).</li><li><code>exit::Symbol</code>: Exit direction (<code>:L</code>, <code>:R</code>, <code>:T</code>, or <code>:B</code>).</li><li><code>_splitdim::Int</code>: _splitting dimension (<code>1</code> for x-axis, <code>2</code> for y-axis).</li><li><code>entry_pt::Tuple{Float64, Float64}</code>: Coordinates of the entry point.</li><li><code>_splitval::Float64</code>: Value of the <em>splitting plane along `</em>splitdim`.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of symbols indicating the traversal order of child nodes (e.g., <code>[:left, :right]</code>).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; _step(:L, :R, 1, (0.0, 0.5), 0.3)
[:left, :right]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._stereodown-Tuple{Any}" href="#GraphLab._stereodown-Tuple{Any}"><code>GraphLab._stereodown</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_stereodown(xyz::AbstractMatrix)</code></pre><p>Performs the inverse of stereographic projection, mapping points from the unit sphere in ℝ^{d} (embedded in ℝ^{d+1}) back to Euclidean space ℝ^{d}.</p><p><strong>Arguments</strong></p><ul><li><code>xyz::AbstractMatrix</code>: An <code>n × (d + 1)</code> matrix where each row is a point on the unit sphere in ℝ^d.</li></ul><p><strong>Returns</strong></p><ul><li><code>xy::Matrix{Float64}</code>: An <code>n × d</code> matrix of projected points in Euclidean space.</li></ul><p><strong>Notes</strong></p><ul><li>Assumes the last coordinate in each row of <code>xyz</code> corresponds to the vertical axis (pole).</li><li>This operation is the inverse of the stereographic projection performed in <code>_stereoup</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._stereoup-Tuple{Matrix{Float64}}" href="#GraphLab._stereoup-Tuple{Matrix{Float64}}"><code>GraphLab._stereoup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Stereographically lift points to the unit sphere in (d+1)-dimensional space.</p><p>coords: n × d matrix of points Returns: n × (d+1) matrix on the unit sphere</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._traverse_kd" href="#GraphLab._traverse_kd"><code>GraphLab._traverse_kd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_traverse_kd(node::KdNode, entry::Symbol=:L, exit::Symbol=:R, last_exits::Vector{Any}=[], acc::Vector{Any}=[])</code></pre><p>Traverse a kd-tree following an adaptive space-filling curve and collect leaf data.</p><p>This function recursively traverses a kd-tree according to entry and exit directions, determining the order of child traversal at each node using adaptive rules. At each leaf node, it collects the stored data into an accumulator.</p><p><strong>Arguments</strong></p><ul><li><code>node::KdNode</code>: The kd-tree node to traverse.</li><li><code>entry::Symbol=:L</code>: Entry direction (<code>:L</code>, <code>:R</code>, <code>:T</code>, <code>:B</code>) at the current node.</li><li><code>exit::Symbol=:R</code>: Exit direction at the current node.</li><li><code>last_exits::Vector{Any}=[]</code>: List of exit points accumulated during traversal.</li><li><code>acc::Vector{Any}=[]</code>: Accumulator for collected leaf data.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>node.is_root</code>, returns <code>acc</code>, the accumulated leaf data in traversal order.</li><li>Otherwise returns the last exit point from the traversal.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = _traverse_kd(tree)
[[x1, y1, id1], [x2, y2, id2], ...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._vis_graph-Tuple{SparseArrays.SparseMatrixCSC, Matrix, Vector{Int64}}" href="#GraphLab._vis_graph-Tuple{SparseArrays.SparseMatrixCSC, Matrix, Vector{Int64}}"><code>GraphLab._vis_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_vis_graph(A::SparseMatrixCSC, coords::Matrix, p::Vector{Int})</code></pre><p>Visualize the partitioning <code>p</code> of graph <code>A</code> using node coordinates <code>coords</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Adjacency matrix of the graph.</li><li><code>coords</code>: Node coordinates for plotting.</li><li><code>p</code>: Partition labels for each node.</li></ul><p><strong>Output</strong></p><ul><li>Displays the partitioned graph visualization.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._vtxsep-NTuple{4, Any}" href="#GraphLab._vtxsep-NTuple{4, Any}"><code>GraphLab._vtxsep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_vtxsep(gborder, p1border, p2border, match)</code></pre><p>Computes a vertex separator based on alternating paths in a bipartite border graph.</p><p><strong>Arguments</strong></p><ul><li><code>gborder::Graph</code>: Bipartite graph between border nodes.</li><li><code>p1border::Vector{Int}</code>: Border nodes from partition 1.</li><li><code>p2border::Vector{Int}</code>: Border nodes from partition 2.</li><li><code>match</code>: Maximum matching result on <code>gborder</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>(sep, new_p1border, new_p2border)</code>: <ul><li><code>sep</code>: Separator set of vertices.</li><li><code>new_p1border</code>: Updated partition 1 border after separator removal.</li><li><code>new_p2border</code>: Updated partition 2 border after separator removal.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Traverses alternating paths between matching and non-matching edges to construct the separator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.grid_graph-Tuple{Int64, Int64, Float64}" href="#GraphLab.grid_graph-Tuple{Int64, Int64, Float64}"><code>GraphLab.grid_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_graph(n::Int, m::Int, α::Float64)</code></pre><p>Returns the adjacency matrix <code>A::SparseMatrixCSC</code> and the coordinates <code>coords::Matrix{Float64}</code> of an <code>n × m</code> grid graph rotated by angle <code>α</code> (in radians).</p><p>Vertices are ordered row-wise: vertex <code>i,j</code> has index <code>(i-1)*m + j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.wait_for_key-Tuple{Any}" href="#GraphLab.wait_for_key-Tuple{Any}"><code>GraphLab.wait_for_key</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">wait_for_key(prompt)</code></pre><p>Prints a prompt to the standard output and waits for a single keypress from the user.</p><p><strong>Arguments</strong></p><ul><li><code>prompt::String</code>: The message to display before waiting for input.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.2 on <span class="colophon-date" title="Saturday 24 May 2025 10:55">Saturday 24 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
