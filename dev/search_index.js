var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This section lists the public functions and types exported by GraphLab.jl.","category":"page"},{"location":"api/#GraphLab.build_adjacency-Tuple{Matrix{Int64}, Int64}","page":"API Reference","title":"GraphLab.build_adjacency","text":"build_adjacency(edges::Matrix{Int}, num_nodes::Int)\n\nConstruct the adjacency matrix of a graph from an edge list.\n\nArguments\n\nedges::Matrix: Matrix where each row represents an edge [u, v].\nnum_nodes::Int: Total number of nodes in the graph.\n\nReturns\n\nA symmetric sparse adjacency matrix (SparseMatrixCSC{Int, Int}).\n\nExample\n\njulia> edges = [1 2; 2 3; 3 1]\njulia> A = build_adjacency(edges, 3)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphLab.build_adjacency-Tuple{String}","page":"API Reference","title":"GraphLab.build_adjacency","text":"build_adjacency(type::String)\n\nGenerate a predefined adjacency matrix and corresponding node coordinates.\n\nArguments\n\ntype::String: Type of graph to generate.  \n\"network\": A predefined network structure.  \n\"triangles\": A small triangular mesh structure.\n\nReturns\n\nA::SparseMatrixCSC: The sparse adjacency matrix of the graph.\ncoords::Matrix: Node coordinates for visualization.\n\nExample\n\njulia> A, coords = build_adjacency(\"network\")\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphLab.compute_partition_balance-Tuple{AbstractVector}","page":"API Reference","title":"GraphLab.compute_partition_balance","text":"compute_partition_balance(p::AbstractVector) -> Float64\n\nComputes the balance metric of a given graph partitioning.\n\nParameters\n\np::AbstractVector: A vector where p[i] represents the partition index assigned to vertex i.\n\nReturns\n\nFloat64: The balance metric, defined as the ratio of the largest partition size to the ideal partition size. A value close to 1.0 indicates a well-balanced partitioning, while higher values suggest imbalance.\n\nExample\n\njulia> p = [1, 1, 2, 2, 2, 3, 3, 3, 3]  # Example partitioning\njulia> balance = compute_partition_balance(p)\njulia> println(balance)  # Output close to 1 for balanced partitions\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphLab.count_edge_cut-Tuple{AbstractMatrix, AbstractVector}","page":"API Reference","title":"GraphLab.count_edge_cut","text":"count_edge_cut(A::AbstractMatrix, p::AbstractVector)\n\nCount the number of edges that cross partitions in the graph A.\n\nArguments\n\nA::AbstractMatrix: Adjacency matrix of the graph.\np::AbstractVector: Partition vector where p[v] represents the partition of vertex v.\n\nReturns\n\nThe number of edges that connect nodes in different partitions.\n\nExample\n\njulia> count_edge_cut(A, p)\n15\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphLab.draw_graph-Tuple{SparseArrays.SparseMatrixCSC, Matrix, Vector{Int64}}","page":"API Reference","title":"GraphLab.draw_graph","text":"draw_graph(A::SparseMatrixCSC, coords::Matrix, p::Vector{Int}; file_name::Union{String, Nothing}=nothing)\n\nDraw and optionally save a visualization of the partitioned graph A.\n\nArguments\n\nA: Adjacency matrix of the graph.\ncoords: Node coordinates for plotting.\np: Partition labels for each node.\nfile_name (optional): If provided, saves the figure to the specified file.\n\nOutput\n\nReturns the generated figure.\nSaves the figure if file_name is specified.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphLab.draw_graph-Tuple{SparseArrays.SparseMatrixCSC, Matrix}","page":"API Reference","title":"GraphLab.draw_graph","text":"draw_graph(A::SparseMatrixCSC, coords::Matrix; file_name::Union{String, Nothing}=nothing)\n\nDraw and optionally save a visualization of the graph A without partitioning.\n\nArguments\n\nA: Adjacency matrix of the graph.\ncoords: Node coordinates for plotting.\nfile_name (optional): If provided, saves the figure to the specified file.\n\nOutput\n\nReturns the generated figure.\nSaves the figure if file_name is specified.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphLab.nested_dissection-Tuple{SparseArrays.SparseMatrixCSC, Function}","page":"API Reference","title":"GraphLab.nested_dissection","text":"nested_dissection(A::SparseMatrixCSC, method::Function; coords=nothing, minsep=5, verbose=false)\n\nComputes a nested dissection ordering of the sparse matrix A using a given separator method.\n\nArguments\n\nA::SparseMatrixCSC: The sparse matrix.\nmethod::Function: Function to compute graph separators.\ncoords::Union{Matrix, Nothing}: Optional node coordinates for geometric methods (default is nothing).\nminsep::Int: Minimum component size to stop recursion (default is 10).\nverbose::Bool: Whether to display visualizations and pause for input during recursion (default is false).\n\nReturns\n\npA::Vector{Int}: The computed permutation vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphLab.part_adaptive_sfc","page":"API Reference","title":"GraphLab.part_adaptive_sfc","text":"part_adaptive_sfc(A::SparseMatrixCSC, coords::Matrix, k::Int=2)\n\nPartition a graph using an adaptive space-filling curve traversal.\n\nThis function builds a kd-tree from node coordinates, traverses the tree following an adaptive space-filling curve, and assigns partition labels based on traversal order. It returns a partition vector that assigns each node to one of k partitions.\n\nThis algorithm is based on \"A General Space-filling Curve Algorithm for Partitioning 2D Meshes\" (Aparna et al., 2015, DOI: 10.1109/HPCC-CSS-ICESS.2015.192) and \"Space-filling Curves for Partitioning Adaptively Refined Meshes\" (Sasidharan, Aparna, and Snir).\n\nArguments\n\nA::SparseMatrixCSC: Adjacency matrix of the graph.\ncoords::Matrix: An n × 2 matrix of node coordinates.\nk::Int=2: Number of partitions.\n\nReturns\n\nA vector part of length n assigning each node to a partition labeled 1 to k.\n\nExample\n\njulia> part = part_adaptive_sfc(A, coords, 4)\n[1, 1, 2, 2, 3, 4, 4, ...]\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphLab.part_coordinate-Tuple{SparseArrays.SparseMatrixCSC, Matrix}","page":"API Reference","title":"GraphLab.part_coordinate","text":"part_coordinate(A::SparseMatrixCSC, coords::Matrix)\n\nCompute a bi-partition of the graph A using the coordinate method based on coords.\n\nArguments\n\nA::SparseMatrixCSC: Adjacency matrix of the graph.\ncoords::Matrix: Node coordinates used for partitioning.\n\nReturns\n\nA vector of partition labels for each node.\n\nExample\n\njulia> part_coordinate(A, coords)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphLab.part_geospectral-Tuple{SparseArrays.SparseMatrixCSC}","page":"API Reference","title":"GraphLab.part_geospectral","text":"part_geospectral(A::SparseMatrixCSC; ev::Int=2)\n\nPerforms spectral partitioning by projecting the graph onto its low-frequency Laplacian eigenvectors, followed by geometric random sphere partitioning in the resulting embedding space.\n\nArguments\n\nA::SparseMatrixCSC: The adjacency matrix of an undirected graph.\nev::Int=2: The number of Laplacian eigenvectors to use for embedding (default is 2).\n\nReturns\n\np::Vector{Int}: A partition of the vertex set, typically as cluster labels.\n\nNotes\n\nEmits a warning if the graph is large, as eigen decomposition may become computationally expensive.\nThis combines spectral embedding with geometric partitioning for improved structural fidelity.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphLab.part_inertial-Tuple{SparseArrays.SparseMatrixCSC, Matrix}","page":"API Reference","title":"GraphLab.part_inertial","text":"part_inertial(A::SparseMatrixCSC, coords::Matrix)\n\nCompute a bi-partition of the graph A using the inertial method based on coords.\n\nArguments\n\nA::SparseMatrixCSC: Adjacency matrix of the graph.\ncoords::Matrix: Node coordinates used for partitioning.\n\nReturns\n\nA vector of partition labels for each node.\n\nExample\n\njulia> part_inertial(A, coords)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphLab.part_metis","page":"API Reference","title":"GraphLab.part_metis","text":"part_metis(A::SparseMatrixCSC, k::Int, alg::Symbol)\n\nPartition the graph A into k parts using METIS with the specified algorithm.\n\nArguments\n\nA: Adjacency matrix of the graph.\nk: Number of partitions.\nalg: Partitioning algorithm (:KWAY or :RECURSIVE).\n\nOutput\n\nReturns a vector of partition labels for each node.\n\nExamples\n\njulia> part_metis(A, 2, :RECURSIVE)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphLab.part_randsphere-Tuple{SparseArrays.SparseMatrixCSC, Matrix{Float64}}","page":"API Reference","title":"GraphLab.part_randsphere","text":"part_randsphere(A, coords; ntrials)\n\nGeometric _partitioning using random spheres and lines.\n\nArguments:\n\nA::SparseMatrixCSC: adjacency matrix\ncoords::Matrix{Float64}: n × d node positions\nntries::Int (optional): number of directions to try (default: 30)\n\nReturns:\n\npart1, part2: vectors of node indices\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphLab.part_sfc","page":"API Reference","title":"GraphLab.part_sfc","text":"part_sfc(A::SparseMatrixCSC, coords::Matrix, k::Int=2, curve::Symbol=:gilbert)\n\nPartition the graph A into k parts using a space-filling curve on coords.\n\nThe coordinates are projected to a grid and ordered according to the selected space-filling curve (:gilbert or :morton). The resulting 1D ordering is then split into k contiguous segments.\n\nArguments\n\nA::SparseMatrixCSC: Adjacency matrix of the graph.\ncoords::Matrix: Node coordinates used for projection to grid.\nk::Int: Number of partitions (default = 2).\ncurve::Symbol: Curve type, one of :gilbert or :morton.\n\nReturns\n\nA vector of partition labels (1 to k) for each node.\n\nExample\n\njulia> part_sfc(A, coords, 4, :morton)\n 1\n ⋮\n 4\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphLab.part_spectral-Tuple{SparseArrays.SparseMatrixCSC}","page":"API Reference","title":"GraphLab.part_spectral","text":"part_spectral(A::SparseMatrixCSC; fiedler::Bool=false)\n\nCompute a bi-partition of the graph A using the spectral method.\n\nArguments\n\nA::SparseMatrixCSC: Adjacency matrix of the graph.\nfiedler::Bool=false: If true, returns the Fiedler vector instead of partition labels.\n\nReturns\n\nA vector of partition labels (1 or 2).\nIf fiedler=true, returns the Fiedler vector.\n\nExample\n\njulia> part_spectral(A)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphLab.recursive_bisection","page":"API Reference","title":"GraphLab.recursive_bisection","text":"recursive_bisection(method::Function, k::Int, A::AbstractSparseMatrix, \n                    coords::Union{Matrix, Nothing}=nothing, minpoints::Int=8)\n\nPartition the graph A into k parts using recursive bisection with the specified partitioning method.\n\nArguments\n\nmethod::Function: Partitioning method to apply at each bisection step (e.g., part_spectral, part_inertial).\nk::Int: Number of partitions (must be a power of 2 or will be rounded up).\nA::AbstractSparseMatrix: Adjacency matrix of the graph.\ncoords::Union{Matrix, Nothing}=nothing: Node coordinates for spatial partitioning (optional).\nminpoints::Int=8: Minimum number of nodes required for further partitioning.\n\nReturns\n\nA vector of partition labels for each node.\n\nExample\n\njulia> recursive_bisection(part_spectral, 4, A, coords)\n 1\n ⋮\n 4\n\n\n\n\n\n","category":"function"},{"location":"usage/#Usage-Guide","page":"Usage Guide","title":"Usage Guide","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"This guide shows how to use GraphLab.jl for various tasks.","category":"page"},{"location":"usage/#Running-Examples","page":"Usage Guide","title":"Running Examples","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"The package includes example scripts in the GraphLab/examples/ directory. These scripts demonstrate how to use the package to benchmark and compare different graph partitioning methods.","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"To run these examples you need to clone the repo using the command:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"git clone https://github.com/lechekhabm/GraphLab.jl","category":"page"},{"location":"usage/#Quick-Start-Example","page":"Usage Guide","title":"Quick Start Example","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"using GraphLab\n\nA, coords = GraphLab.build_adjacency(\"network\")\np = GraphLab.part_spectral(A)\nGraphLab.draw_graph(A, coords, p, file_name=\"test.png\")","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"A simple example demonstrating the usage of GraphLab.jl is available in this Google Colab notebook: Open in Colab.","category":"page"},{"location":"usage/#Example-1:-Comparing-Partitioning-Methods","page":"Usage Guide","title":"Example 1: Comparing Partitioning Methods","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Script: GraphLab.jl/examples/ex1.jl","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"This example compares different graph partitioning methods, including:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Coordinate Bisection\nInertial Bisection\nSpectral Bisection\nBisection using METIS","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"The script evaluates these methods on a series of different graphs, providing insights into their performance and effectiveness.","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"<!-- 2x2 Grid for Airfoil1 Examples -->\n<table style=\"width:100%; border-collapse: collapse;\">\n  <tr>\n    <!-- Coordinate Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 0;\">\n      <img src=\"https://github.com/lechekhabm/GraphLab.jl/blob/main/examples/ex1_airfoil1_coordinate.png?raw=true\" alt=\"Coordinate Bisection\" style=\"width:100%; margin:0; padding:0;\">\n      <p style=\"margin: 0; padding: 0;\"><em>Coordinate Bisection</em></p>\n    </td>\n    <!-- Inertial Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 0;\">\n      <img src=\"https://github.com/lechekhabm/GraphLab.jl/blob/main/examples/ex1_airfoil1_inertial.png?raw=true\" alt=\"Inertial Bisection\" style=\"width:100%; margin:0; padding:0;\">\n      <p style=\"margin: 0; padding: 0;\"><em>Inertial Bisection</em></p>\n    </td>\n  </tr>\n  <tr>\n    <!-- Spectral Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 0;\">\n      <img src=\"https://github.com/lechekhabm/GraphLab.jl/blob/main/examples/ex1_airfoil1_spectral.png?raw=true\" alt=\"Spectral Bisection\" style=\"width:100%; margin:0; padding:0;\">\n      <p style=\"margin: 0; padding: 0;\"><em>Spectral Bisection</em></p>\n    </td>\n    <!-- METIS Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 0;\">\n      <img src=\"https://github.com/lechekhabm/GraphLab.jl/blob/main/examples/ex1_airfoil1_metis.png?raw=true\" alt=\"METIS Bisection\" style=\"width:100%; margin:0; padding:0;\">\n      <p style=\"margin: 0; padding: 0;\"><em>METIS</em></p>\n    </td>\n  </tr>\n</table>","category":"page"},{"location":"usage/#How-to-Run-Example-1","page":"Usage Guide","title":"How to Run Example 1","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Navigate to the examples directory:\ncd GraphLab.jl/examples\nRun the example script in the Julia or directly from the terminal:\njulia ex1.jl","category":"page"},{"location":"usage/#Example-2:-Recursive-Bisection","page":"Usage Guide","title":"Example 2: Recursive Bisection","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Script: GraphLab.jl/examples/ex2.jl","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"This example demonstrates recursive bisection using different methods, including:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Coordinate Bisection\nInertial Bisection\nSpectral Bisection\nRecursive Bisection using METIS K-way","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"<table style=\"width:100%; border-collapse: collapse;\">\n  <tr>\n    <!-- Recursive Coordinate Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 10px;\">\n      <img src=\"https://github.com/lechekhabm/GraphLab.jl/blob/main/examples/ex2_Swiss_graph_coordinate.png?raw=true\" alt=\"Recursive Coordinate Bisection\" style=\"width:100%;\">\n      <p style=\"font-size: 12px;\"><em>Recursive Coordinate Bisection</em></p>\n    </td>\n    <!-- Recursive Inertial Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 10px;\">\n      <img src=\"https://github.com/lechekhabm/GraphLab.jl/blob/main/examples/ex2_Swiss_graph_inertial.png?raw=true\" alt=\"Recursive Inertial Bisection\" style=\"width:100%;\">\n      <p style=\"font-size: 12px;\"><em>Recursive Inertial Bisection</em></p>\n    </td>\n  </tr>\n  <tr>\n    <!-- Recursive Spectral Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 10px;\">\n      <img src=\"https://github.com/lechekhabm/GraphLab.jl/blob/main/examples/ex2_Swiss_graph_spectral.png?raw=true\" alt=\"Recursive Spectral Bisection\" style=\"width:100%;\">\n      <p style=\"font-size: 12px;\"><em>Recursive Spectral Bisection</em></p>\n    </td>\n    <!-- Recursive METIS Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 10px;\">\n      <img src=\"https://github.com/lechekhabm/GraphLab.jl/blob/main/examples/ex2_Swiss_graph_metis_rec.png?raw=true\" alt=\"Recursive METIS Bisection\" style=\"width:100%;\">\n      <p style=\"font-size: 12px;\"><em>Recursive METIS Bisection (K-way is also available)</em></p>\n    </td>\n  </tr>\n</table>","category":"page"},{"location":"usage/#How-to-Run-Example-2","page":"Usage Guide","title":"How to Run Example 2","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Navigate to the examples directory:\ncd GraphLab.jl/examples\nRun the example script in the Julia or directly from the terminal:\njulia ex2.jl","category":"page"},{"location":"#GraphLab.jl-Documentation","page":"Home","title":"GraphLab.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphLab.jl is a Julia package designed to make graph partitioning approachable, interactive, and educational. Rather than focusing purely on production-ready pipelines, GraphLab.jl provides a hands-on framework for exploring, experimenting, and teaching graph partitioning techniques.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It offers an accessible collection of algorithms, including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Coordinate, inertial, spectral, and random sphere bisection.\nSpace-filling curve partitioning.\nRecursive partitioning and nested dissection.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Beyond algorithms, GraphLab.jl includes tools for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Generating and manipulating adjacency matrices.\nEvaluating partition quality.\nBenchmarking algorithms.\nVisualizing partitioned graphs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GraphLab.jl also integrates with external partitioners, enabling easy method comparisons in a unified Julia environment.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GraphLab.jl aims to support the Julia graph community's educational and exploratory needs, helping learners and researchers engage with graph theory in an interactive and practical way.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package from GitHub and add it to your working environment, follow these steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Add the GraphLab.jl to you project using the Julia command:\nusing Pkg\nPkg.add(url=\"https://github.com/lechekhabm/GraphLab.jl\")\nNote: If you have an SSH key set up with GitHub, you can install the package using SSH:\nPkg.add(url=\"https://<YOUR_GITHUB_TOKEN>@github.com/lechekhabm/GraphLab.jl.git\")\nReplace <YOUR_GITHUB_TOKEN> with a valid token that has repository read access.\nBasic Example:\nusing GraphLab\nA, coords = GraphLab.grid_graph(10, 50, π/3)\np = GraphLab.part_spectral(A)\nGraphLab.draw_graph(A, coords, p, file_name=\"test.png\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For further details on the package and its functions, see the Usage Guide.","category":"page"},{"location":"#Prerequisites-and-Dependencies","page":"Home","title":"Prerequisites and Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package will automatically install the following dependencies: Arpack, CairoMakie, Colors, Graphs, LinearAlgebra, Metis, SparseArrays, Statistics, AMD, GraphsMatching, JuMP, and Cbc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For additional usability, you may need the following packages: DelimitedFiles, MAT, Plots, and PrettyTables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Refer to the source code and Project.toml files within the examples/ directory for further details about dependencies and configurations. Additional explanations are provided later in this document.","category":"page"},{"location":"#Future-Work","page":"Home","title":"Future Work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Support for higher-dimensional graphs and hypergraphs\nAutomated detection of external software\nPerformance optimizations\nSupport for additional partitioning methods\nEnhanced documentation and tutorials\nInteractive visualization","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use GraphLab.jl in your research or teaching, please consider citing our upcoming paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{GraphLab2025,\nauthor = {Malik Lechekhab and collaborators},\ntitle = {GraphLab.jl: A Julia Framework for Exploring Graph Partitioning},\njournal = {In preparation},\nyear = {2025},\nnote = {Preprint will be made available at arXiv},\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"We will update the citation once the paper is published.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Malik Lechekhab (Institute of Computing, Università della Svizzera italiana)\nDimosthenis Pasadakis (Institute of Computing, Università della Svizzera italiana)\nAryan Eftekhari (Institute of Computing, Università della Svizzera italiana)\nRoger Käppeli (Department of Mathematics, ETH Zürich)\nOlaf Schenk (Institute of Computing, Università della Svizzera italiana)","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Jeroen Baert, Libmorton: C++ Morton Encoding/Decoding Library, 2018. Link.\nAparna Sasidharan, Aparna, and Snir, Space-filling Curves for Partitioning Adaptively Refined Meshes.\nAparna Sasidharan, John R. Gilbert, Shang-Hua Teng, Yingzhou Li, A General Space-filling Curve Algorithm for Partitioning 2D Meshes, In Proceedings of the 2015 IEEE 17th International Conference on High Performance Computing and Communications (HPCC), 2015. DOI: 10.1109/HPCC-CSS-ICESS.2015.192.\nSimon Byrne, GilbertCurves.jl, Link.\nJakub Červený, gilbert, Link.\nYingzhou Li, meshpart Toolbox, Link.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We would also like to thank the authors of SGtSNEpi.jl for their work, which served as a reference for the graph plotting function in this project.","category":"page"},{"location":"documentation/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"documentation/#Graph-Construction","page":"Documentation","title":"Graph Construction","text":"","category":"section"},{"location":"documentation/#GraphLab.build_adjacency","page":"Documentation","title":"GraphLab.build_adjacency","text":"build_adjacency(edges::Matrix{Int}, num_nodes::Int)\n\nConstruct the adjacency matrix of a graph from an edge list.\n\nArguments\n\nedges::Matrix: Matrix where each row represents an edge [u, v].\nnum_nodes::Int: Total number of nodes in the graph.\n\nReturns\n\nA symmetric sparse adjacency matrix (SparseMatrixCSC{Int, Int}).\n\nExample\n\njulia> edges = [1 2; 2 3; 3 1]\njulia> A = build_adjacency(edges, 3)\n\n\n\n\n\nbuild_adjacency(type::String)\n\nGenerate a predefined adjacency matrix and corresponding node coordinates.\n\nArguments\n\ntype::String: Type of graph to generate.  \n\"network\": A predefined network structure.  \n\"triangles\": A small triangular mesh structure.\n\nReturns\n\nA::SparseMatrixCSC: The sparse adjacency matrix of the graph.\ncoords::Matrix: Node coordinates for visualization.\n\nExample\n\njulia> A, coords = build_adjacency(\"network\")\n\n\n\n\n\n","category":"function"},{"location":"documentation/#Native-Partitioning-Methods","page":"Documentation","title":"Native Partitioning Methods","text":"","category":"section"},{"location":"documentation/#GraphLab.part_coordinate","page":"Documentation","title":"GraphLab.part_coordinate","text":"part_coordinate(A::SparseMatrixCSC, coords::Matrix)\n\nCompute a bi-partition of the graph A using the coordinate method based on coords.\n\nArguments\n\nA::SparseMatrixCSC: Adjacency matrix of the graph.\ncoords::Matrix: Node coordinates used for partitioning.\n\nReturns\n\nA vector of partition labels for each node.\n\nExample\n\njulia> part_coordinate(A, coords)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GraphLab.part_inertial","page":"Documentation","title":"GraphLab.part_inertial","text":"part_inertial(A::SparseMatrixCSC, coords::Matrix)\n\nCompute a bi-partition of the graph A using the inertial method based on coords.\n\nArguments\n\nA::SparseMatrixCSC: Adjacency matrix of the graph.\ncoords::Matrix: Node coordinates used for partitioning.\n\nReturns\n\nA vector of partition labels for each node.\n\nExample\n\njulia> part_inertial(A, coords)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GraphLab.part_spectral","page":"Documentation","title":"GraphLab.part_spectral","text":"part_spectral(A::SparseMatrixCSC; fiedler::Bool=false)\n\nCompute a bi-partition of the graph A using the spectral method.\n\nArguments\n\nA::SparseMatrixCSC: Adjacency matrix of the graph.\nfiedler::Bool=false: If true, returns the Fiedler vector instead of partition labels.\n\nReturns\n\nA vector of partition labels (1 or 2).\nIf fiedler=true, returns the Fiedler vector.\n\nExample\n\njulia> part_spectral(A)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GraphLab.part_metis","page":"Documentation","title":"GraphLab.part_metis","text":"part_metis(A::SparseMatrixCSC, k::Int, alg::Symbol)\n\nPartition the graph A into k parts using METIS with the specified algorithm.\n\nArguments\n\nA: Adjacency matrix of the graph.\nk: Number of partitions.\nalg: Partitioning algorithm (:KWAY or :RECURSIVE).\n\nOutput\n\nReturns a vector of partition labels for each node.\n\nExamples\n\njulia> part_metis(A, 2, :RECURSIVE)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"function"},{"location":"documentation/#Recursive-Bisection","page":"Documentation","title":"Recursive Bisection","text":"","category":"section"},{"location":"documentation/#GraphLab.recursive_bisection","page":"Documentation","title":"GraphLab.recursive_bisection","text":"recursive_bisection(method::Function, k::Int, A::AbstractSparseMatrix, \n                    coords::Union{Matrix, Nothing}=nothing, minpoints::Int=8)\n\nPartition the graph A into k parts using recursive bisection with the specified partitioning method.\n\nArguments\n\nmethod::Function: Partitioning method to apply at each bisection step (e.g., part_spectral, part_inertial).\nk::Int: Number of partitions (must be a power of 2 or will be rounded up).\nA::AbstractSparseMatrix: Adjacency matrix of the graph.\ncoords::Union{Matrix, Nothing}=nothing: Node coordinates for spatial partitioning (optional).\nminpoints::Int=8: Minimum number of nodes required for further partitioning.\n\nReturns\n\nA vector of partition labels for each node.\n\nExample\n\njulia> recursive_bisection(part_spectral, 4, A, coords)\n 1\n ⋮\n 4\n\n\n\n\n\n","category":"function"},{"location":"documentation/#Visualization","page":"Documentation","title":"Visualization","text":"","category":"section"},{"location":"documentation/#GraphLab.draw_graph","page":"Documentation","title":"GraphLab.draw_graph","text":"draw_graph(A::SparseMatrixCSC, coords::Matrix, p::Vector{Int}; file_name::Union{String, Nothing}=nothing)\n\nDraw and optionally save a visualization of the partitioned graph A.\n\nArguments\n\nA: Adjacency matrix of the graph.\ncoords: Node coordinates for plotting.\np: Partition labels for each node.\nfile_name (optional): If provided, saves the figure to the specified file.\n\nOutput\n\nReturns the generated figure.\nSaves the figure if file_name is specified.\n\n\n\n\n\ndraw_graph(A::SparseMatrixCSC, coords::Matrix; file_name::Union{String, Nothing}=nothing)\n\nDraw and optionally save a visualization of the graph A without partitioning.\n\nArguments\n\nA: Adjacency matrix of the graph.\ncoords: Node coordinates for plotting.\nfile_name (optional): If provided, saves the figure to the specified file.\n\nOutput\n\nReturns the generated figure.\nSaves the figure if file_name is specified.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#Utility-Function","page":"Documentation","title":"Utility Function","text":"","category":"section"},{"location":"documentation/#GraphLab.count_edge_cut","page":"Documentation","title":"GraphLab.count_edge_cut","text":"count_edge_cut(A::AbstractMatrix, p::AbstractVector)\n\nCount the number of edges that cross partitions in the graph A.\n\nArguments\n\nA::AbstractMatrix: Adjacency matrix of the graph.\np::AbstractVector: Partition vector where p[v] represents the partition of vertex v.\n\nReturns\n\nThe number of edges that connect nodes in different partitions.\n\nExample\n\njulia> count_edge_cut(A, p)\n15\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GraphLab.compute_partition_balance","page":"Documentation","title":"GraphLab.compute_partition_balance","text":"compute_partition_balance(p::AbstractVector) -> Float64\n\nComputes the balance metric of a given graph partitioning.\n\nParameters\n\np::AbstractVector: A vector where p[i] represents the partition index assigned to vertex i.\n\nReturns\n\nFloat64: The balance metric, defined as the ratio of the largest partition size to the ideal partition size. A value close to 1.0 indicates a well-balanced partitioning, while higher values suggest imbalance.\n\nExample\n\njulia> p = [1, 1, 2, 2, 2, 3, 3, 3, 3]  # Example partitioning\njulia> balance = compute_partition_balance(p)\njulia> println(balance)  # Output close to 1 for balanced partitions\n\n\n\n\n\n","category":"function"},{"location":"documentation/#Interfacing-with-External-Partitioning-Tools","page":"Documentation","title":"Interfacing with External Partitioning Tools","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"To integrate with graph partitioning tools such as KaHIP, Graclus, and MDC, we provide utility functions for exporting graph structures, executing external commands, and managing dependencies. These functions streamline the workflow, ensuring compatibility with external software while maintaining interoperability with GraphLab.jl.","category":"page"},{"location":"documentation/#Writing-a-Graph-File-for-Partitioning-Tools","page":"Documentation","title":"Writing a Graph File for Partitioning Tools","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"This function generates a graph file compatible with tools like KaHIP, Graclus, and MDC from a symmetric adjacency matrix. Steps:     1. Extract the number of nodes and edges from the adjacency matrix.     2. Create a temporary file or save it to ./adjacency_lists depending on the temp flag.     3. Write the graph format:         - The first line contains the number of nodes and edges.         - Each subsequent line lists the neighbors of a node.","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Usage:     - If temp=true, the file is temporary.     - If temp=false, the file is saved in ./adjacency_lists with a specified prefix.","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"function _write_partition_input(A::SparseMatrixCSC; prefix::String=\"graph\", temp::Bool=false)\n    n_nodes = size(A, 1)\n    I, J, _ = findnz(A)\n    n_edges = div(length(I), 2)\n\n    if temp\n        mktemp() do file, _\n            write(file, \"$n_nodes $n_edges\\n\")\n\n            for i in 1:n_nodes  \n                neighbors = J[findall(==(i), I)]\n                write(file, join(neighbors, \" \") * \"\\n\")\n            end\n\n            return file\n        end\n    else\n        dir = \"./adjacency_lists\"\n        mkpath(dir)\n        file_path = joinpath(dir, \"$prefix.graph\")\n\n        open(file_path, \"w\") do file\n            write(file, \"$n_nodes $n_edges\\n\")\n            for i in 1:n_nodes\n                neighbors = J[findall(==(i), I)]\n                write(file, join(neighbors, \" \") * \"\\n\")\n            end\n        end\n\n        return file_path\n    end\nend","category":"page"},{"location":"documentation/#Running-an-External-Command-and-Capturing-Output","page":"Documentation","title":"Running an External Command and Capturing Output","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"This function runs a shell command and captures both stdout and stderr. Steps:","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"1. Execute the command asynchronously.\n2. Capture stdout and stderr into separate tasks.\n3. Wait for the process to finish and return the outputs.","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"function _run_cmd(cmd::Cmd)\n\tout = Pipe()\n\terr = Pipe()\n\n\tprocess = run(pipeline(cmd, stdout=out, stderr=err), wait=false)\n\n\tclose(out.in)\n\tclose(err.in)\n\n\tstdout_task = @async String(read(out))\n\tstderr_task = @async String(read(err))\n\n\twait(process)\n\n\treturn (\n\t\tstdout = fetch(stdout_task),\n\t\tstderr = fetch(stderr_task),\n\t\tcode = process.exitcode\n\t)\nend","category":"page"},{"location":"documentation/#Retrieving-and-Validating-an-Executable-Path","page":"Documentation","title":"Retrieving and Validating an Executable Path","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"This function retrieves an external executable's path from an environment variable and ensures it exists. Steps:","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"1. Check if the environment variable is set.\n2. Retrieve the executable path.\n3. Verify that the file exists; otherwise, throw an error.","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"function _get_executable(exec_name::String)\n    if !haskey(ENV, exec_name)\n        error(\"❌ Environment variable $exec_name is not set. Please define it with the path to the executable.\")\n    end\n\n    exec_path = ENV[exec_name]\n\n    # Check if the file exists\n    if !isfile(exec_path)\n        error(\"❌ Executable '$exec_path' not found. Please check the $exec_name environment variable.\")\n    end\n\n    return exec_path\nend","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"With these core utility functions in place, we can now implement functions tailored to specific partitioning software.","category":"page"},{"location":"documentation/#Graclus","page":"Documentation","title":"Graclus","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Graclus is a spectral-based graph clustering and partitioning software.  ","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Installation: You need to manually download and compile Graclus from its official source.  \nEnvironment Variable: Set GRACLUS_PATH to point to the compiled Graclus executable.  ","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"export GRACLUS_PATH=\"/path/to/graclus\"","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"function run_graclus(A::SparseMatrixCSC, np::Int; cut_type::String=\"ncut\", local_search::Int=0, dbg::Bool=false)\n\n    mat_path = _write_partition_input(A)\n\n    graclus_exec = _get_executable(\"GRACLUS_PATH\")\n\n\tcmd = `$graclus_exec $mat_path $np -O $cut_type -L $local_search`;\n\n    result = _run_cmd(cmd)\n\t\n    if result.code != 0\n        error(\"❌ Graclus execution failed with error:\\n\" * result.code)\n    end\n\n    partition_file = \"graph.graph\"*\".part.\"*string(np)\n    partitions = Int[]\n\n    try\n        open(partition_file, \"r\") do f\n            for line in eachline(f)\n                push!(partitions, parse(Int, line))\n            end\n        end\n        println(\"✅ Partitions extracted from \", partition_file)\n    catch e\n        error(\"❌ Failed to read partition file '$partition_file': \", e)\n    end\n\n    if dbg\n        println(\"🖥️ Execution Result:\\n\", result.stdout)\n        println(\"📂 Partition File: \", partition_file)\n        println(\"🔢 Partitions: \", partitions)\n        return partitions\n    else\n        # Remove the partition file after reading\n        rm(partition_file, force=true)\n        return partitions\n    end\nend","category":"page"},{"location":"documentation/#Citation","page":"Documentation","title":"Citation","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Weighted Graph Cuts without Eigenvectors: A Multilevel Approach, I. Dhillon, Y. Guan, and B, Kulis, IEEE Transactions on Pattern Analysis and Machine Intelligence (PAMI), vol. 29:11, pages 1944-1957, November 2007.\nA Fast Kernel-based Multilevel Algorithm for Graph Clustering, I. Dhillon, Y. Guan, and B, Kulis, Proceedings of The 11th ACM SIGKDD, Chicago, IL, August 21-24, 2005.\nKernel k-means, Spectral Clustering and Normalized Cuts, I. Dhillon, Y. Guan, and B. Kulis, Proceedings of The 10th ACM SIGKDD, Seattle, WA, August 22-25, 2004.","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"documentation/#KaHIP-(run_kahip)","page":"Documentation","title":"KaHIP (run_kahip)","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"KaHIP (Karlsruhe High-Quality Partitioning) is an efficient graph partitioning tool that supports various heuristics and optimizations.","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Installation: You need to download and compile KaHIP from its official source.\nEnvironment Variable: Set KAHIP_PATH to the KaHIP binary.","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"export KAHIP_PATH=\"/path/to/kahip\"","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"function run_kahip(A::SparseMatrixCSC, np::Int; preconfiguration::String=\"fast\", dbg::Bool=false)\n\n    mat_path = _write_partition_input(A)\n\n    kahip_exec = _get_executable(\"KAHIP_PATH\")\n\n\tcmd = `$kahip_exec $mat_path --k $np --preconfiguration=$preconfiguration`;\n\n    result = _run_cmd(cmd)\n\t\n    if result.code != 0\n        error(\"KaHIP execution failed with error:\\n\" * result.code)\n    end\n\n    partition_file = \"tmppartition\" * string(np)\n    partitions = Int[]\n\n    try\n        open(partition_file, \"r\") do f\n            for line in eachline(f)\n                push!(partitions, parse(Int, line))\n            end\n        end\n        println(\"✅ Partitions extracted from \", partition_file)\n    catch e\n        error(\"❌ Failed to read partition file '$partition_file': \", e)\n    end\n\n    if dbg\n        println(\"🖥️ Execution Result:\\n\", result.stdout)\n        println(\"📂 Partition File: \", partition_file)\n        println(\"🔢 Partitions: \", partitions)\n        return partitions\n    else\n        # Remove the partition file after reading\n        rm(partition_file, force=true)\n        return partitions\n    end\nend","category":"page"},{"location":"documentation/#Citation-2","page":"Documentation","title":"Citation","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Peter Sanders and Christian Schulz. Engineering Multilevel Graph Partitioning Algorithms. In Proceedings of the 19th European Symposium on Algorithms (ESA'11), volume 6942 of LNCS, pages 469–480. Springer, 2011.","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"documentation/#Multi-Level-Diffusion-Clustering-(MDC)-(run_mdc)","page":"Documentation","title":"Multi-Level Diffusion Clustering (MDC) (run_mdc)","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"MDC is an experimental diffusion-based graph partitioning method.","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Installation: You must download, compile, and install MDC following the instructions from official source.\nEnvironment Variable: Set MDC_PATH to point to the MDC executable. It also requires setting LD_LIBRARY_PATH for proper execution.","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"export MDC_PATH=\"/path/to/mdc\"\nexport LD_LIBRARY_PATH=\"/path/to/stag/stag-1.3.0/build_dir/stag_lib/\"","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"function run_mdc(A::SparseMatrixCSC,\n                np::Int;\n                cut_type::String=\"ncut\",\n                local_search::Int=0,\n                beta_testing::Bool=true,\n                spectral_method::Bool=true,\n                beta_min::Int=0,\n                beta_max::Int=2,\n                dbg::Bool=false)\n\n    mat_path = _write_partition_input(A)\n\n    mdc_exec = _get_executable(\"MDC_PATH\")\n\n\tcmd = `$mdc_exec $mat_path $np -b $beta_testing -s $spectral_method -O $cut_type -y $beta_min -z $beta_max -L $local_search`;\n\n    result = _run_cmd(cmd)\n\t\n    if result.code != 0\n        error(\"❌ MDC execution failed with error:\\n\" * result.code)\n    end\n\n    partition_file = \"graph.graph\"*\".part.\"*string(np)\n    partitions = Int[]\n\n    try\n        open(partition_file, \"r\") do f\n            for line in eachline(f)\n                push!(partitions, parse(Int, line))\n            end\n        end\n        println(\"✅ Partitions extracted from \", partition_file)\n    catch e\n        error(\"❌ Failed to read partition file '$partition_file': \", e)\n    end\n\n    if dbg\n        println(\"🖥️ Execution Result:\\n\", result.stdout)\n        println(\"📂 Partition File: \", partition_file)\n        println(\"🔢 Partitions: \", partitions)\n        return partitions\n    else\n        # Remove the partition file after reading\n        rm(partition_file, force=true)\n        return partitions\n    end\nend","category":"page"},{"location":"documentation/#Citation-3","page":"Documentation","title":"Citation","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Lechekhab M., Pasadakis D., Schenk O. (forthcoming) Multilevel Diffusion Based Spectral Graph Clustering. 28th Annual IEEE High Performance Extreme Computing Virtual Conference. IEEE. 28th Annual IEEE High Performance Extreme Computing Virtual Conference. Virtual Conference. September 23-27, 2024","category":"page"},{"location":"dev_api/#Developers-API-Reference","page":"Developers API Reference","title":"Developers API Reference","text":"","category":"section"},{"location":"dev_api/","page":"Developers API Reference","title":"Developers API Reference","text":"This section lists the public and private functions exported by GraphLab.jl.","category":"page"},{"location":"dev_api/#GraphLab.KdNode","page":"Developers API Reference","title":"GraphLab.KdNode","text":"KdNode\n\nA node in a 2D kd-tree data structure, representing a spatial region and its recursive subdivision.\n\nEach node contains bounding box coordinates, optional _splitting information, and links to child nodes. The node can also store associated data points and optional entry/exit traversal symbols for space-filling curve traversal.\n\nFields\n\nbbox::Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}: Bounding box as (min_coords, max_coords).\n_splitdim::Union{Int, Nothing}: _splitting dimension (1 for x-axis, 2 for y-axis), or nothing for leaf.\n_splitval::Union{Float64, Nothing}: Coordinate value of the _splitting plane, or nothing for leaf.\nleft::Union{KdNode, Nothing}: Left child node (subtree with coordinates ≤ _splitval), or nothing.\nright::Union{KdNode, Nothing}: Right child node (subtree with coordinates > _splitval), or nothing.\nis_leaf::Bool: Whether the node is a leaf.\nis_root::Bool: Whether the node is the root of the tree.\ndata::Matrix{Float64}: Data points contained in this node.\nentry::Union{Symbol, Nothing}: Optional entry symbol for space-filling curve traversal.\nexit::Union{Symbol, Nothing}: Optional exit symbol for space-filling curve traversal.\n\n\n\n\n\n","category":"type"},{"location":"dev_api/#GraphLab._append_gilbert!-Tuple{Vector{CartesianIndex{2}}, AbstractMatrix}","page":"Developers API Reference","title":"GraphLab._append_gilbert!","text":"_append_gilbert!(path, grid::AbstractMatrix)\n\nRecursively traverse the given matrix grid using a generalized Gilbert curve pattern. Appends the CartesianIndex entries to path in order.\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._bbox_center-Tuple{Any}","page":"Developers API Reference","title":"GraphLab._bbox_center","text":"_bbox_center(bbox)\n\nCompute the center point of a bounding box.\n\nArguments\n\nbbox: A tuple ((xmin, ymin), (xmax, ymax)) representing the bounding box corners.\n\nReturns\n\nA tuple (xcenter, ycenter) representing the center coordinates of the bounding box.\n\nExample\n\njulia> _bbox_center(((0.0, 0.0), (2.0, 4.0)))\n(1.0, 2.0)\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._bounding_box-Tuple{Matrix{Float64}}","page":"Developers API Reference","title":"GraphLab._bounding_box","text":"_bounding_box(coords::Matrix{Float64})\n\nCompute the axis-aligned bounding box for a set of 2D points.\n\nArguments\n\ncoords::Matrix{Float64}: A matrix of size n × 2, where each row represents a 2D point (x, y).\n\nReturns\n\nA tuple ((xmin, ymin), (xmax, ymax)) representing the lower-left and upper-right corners of the bounding box.\n\nExample\n\njulia> _bounding_box([1.0 2.0; 3.0 4.0; -1.0 5.0])\n((-1.0, 2.0), (3.0, 5.0))\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._build_tree","page":"Developers API Reference","title":"GraphLab._build_tree","text":"_build_tree(coords::Matrix{Float64}, is_root::Bool=true)\n\nRecursively build a 2D kd-tree from a set of points. Leaf nodes contain the data points inside their region.\n\nArguments\n\ncoords::Matrix{Float64}: A matrix of size n × 2, where each row is a 2D point (x, y).\nis_root::Bool=true: Whether this node is the root of the tree (automatically set during recursion).\n\nReturns\n\nA KdNode representing the root of the kd-tree.\n\nExample\n\njulia> tree = _build_tree([1.0 2.0; 3.0 4.0; 0.0 5.0])\nKdNode(...)\n\n\n\n\n\n","category":"function"},{"location":"dev_api/#GraphLab._centerpoint-Tuple{Matrix{Float64}, Int64}","page":"Developers API Reference","title":"GraphLab._centerpoint","text":"Approximate _centerpoint by coordinate-wise median of a random sample.\n\nArguments:\n\nX::Matrix{Float64}: n × d data matrix\nsample_size::Int: number of random rows to sample\n\nReturns:\n\ncenter::Vector{Float64}: estimated _centerpoint\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._conmap-Tuple{Vector{Float64}, Matrix{Float64}}","page":"Developers API Reference","title":"GraphLab._conmap","text":"Conformal map that moves center to the origin on the unit sphere.\n\nArguments:\n\ncenter::Vector{Float64}: _centerpoint on the sphere (length d+1)\nX::Matrix{Float64}: n × (d+1) matrix of lifted points\n\nReturns:\n\nY::Matrix{Float64}: transformed points (same size as X)\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._get_alignment-Tuple{Symbol, Int64}","page":"Developers API Reference","title":"GraphLab._get_alignment","text":"_get_alignment(entry::Symbol, _splitdim::Int)\n\nDetermine the alignment of an entry direction relative to the _splitting dimension.\n\nArguments\n\nentry::Symbol: Entry direction (:L, :R, :T, or :B).\n_splitdim::Int: _splitting dimension (1 for x-axis, 2 for y-axis).\n\nReturns\n\n:parallel if entry edge direction is parallel to the _splitting dimension.\n:perpendicular otherwise.\n\nExample\n\njulia> _get_alignment(:L, 1)\n:parallel\njulia> _get_alignment(:T, 1)\n:perpendicular\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._get_child-Tuple{GraphLab.KdNode, Symbol}","page":"Developers API Reference","title":"GraphLab._get_child","text":"_get_child(node::KdNode, side::Symbol)\n\nReturn the child node of a KdNode corresponding to the specified side.\n\nThis function retrieves either the left or right child node depending on the side and the _splitting dimension.\n\nArguments\n\nnode::KdNode: The kd-tree node.\nside::Symbol: Side indicator (:left, :right, :bottom, or :top).\n\nReturns\n\nThe child KdNode corresponding to the requested side.\n\nExample\n\njulia> _get_child(node, :left)\nKdNode(...)\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._get_child_entry_exit-Tuple{Symbol, Symbol, Int64, Symbol}","page":"Developers API Reference","title":"GraphLab._get_child_entry_exit","text":"_get_child_entry_exit(parent_entry::Symbol, parent_exit::Symbol, _splitdim::Int, side::Symbol)\n\nCompute the entry and exit directions for a child node in a kd-tree traversal.\n\nGiven the parent node’s entry and exit directions, the _splitting dimension, and the side being traversed, this function determines the entry and exit directions for the child node according to space-filling curve traversal rules (using :cis and :tran order types and :parallel / :perpendicular alignment).\n\nArguments\n\nparent_entry::Symbol: Entry direction at the parent node (:L, :R, :T, :B).\nparent_exit::Symbol: Exit direction at the parent node (:L, :R, :T, :B).\n_splitdim::Int: _splitting dimension (1 for x-axis, 2 for y-axis).\nside::Symbol: Side of the child being traversed (:left, :right, :top, :bottom).\n\nReturns\n\nA tuple (child_entry, child_exit) indicating the entry and exit directions for the child node.\n\nExample\n\njulia> _get_child_entry_exit(:L, :R, 1, :left)\n(:L, :R)\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._get_maximum_matching-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"Developers API Reference","title":"GraphLab._get_maximum_matching","text":"_get_maximum_matching(g::Graph)\n\nComputes a maximum weight matching of the graph g using a silent CBC solver.\n\nArguments\n\ng::Graph: The input graph.\n\nReturns\n\nmatch: The matching object containing mate assignments and total weight.\n\nNotes\n\nAssumes unit weights unless otherwise specified.\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._get_partition-Tuple{AbstractVector, Int64}","page":"Developers API Reference","title":"GraphLab._get_partition","text":"_get_partition(v::AbstractVector, k::Int)\n\nCreate a partition indicator vector by dividing indices into k contiguous groups.\n\nThis function assigns partition labels 1 to k to the indices in v, distributing them evenly into k partitions based on their position in v. Each value in v is assumed to be a node ID (1-based indexing), and the result maps each node ID to its partition.\n\nArguments\n\nv::AbstractVector: A vector of node IDs to partition.\nk::Int: The number of partitions.\n\nReturns\n\nA vector part of length maximum(v) where part[id] is the partition label (1 to k) assigned to node id.\n\nExample\n\njulia> _get_partition([1, 2, 3, 4, 5, 6], 2)\n[1, 1, 1, 2, 2, 2]\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._gilbert_indices-Tuple{Tuple{Int64, Int64}}","page":"Developers API Reference","title":"GraphLab._gilbert_indices","text":"_gilbert_indices(grid_dims::Tuple{Int, Int}; maj_axis=grid_dims[1] ≥ grid_dims[2] ? 1 : 2)\n\nGenerate a list of CartesianIndex{2} representing a generalized space-filling traversal of a grid with dimensions grid_dims, using a Gilbert-like curve. Traversal will favor rows (X axis) if maj_axis == 1, or columns (Y axis) if maj_axis == 2.\n\nArguments\n\ngrid_dims::Tuple{Int, Int}: a tuple (rows, cols) specifying grid size.\nmaj_axis: optional; either 1 (row-major preference) or 2 (column-major preference).\nThe curve will traverse more linearly along the maj_axis.\n\nReturns\n\nA Vector{CartesianIndex{2}} representing the traversal path.\n\nExample\n\njulia> order = _gilbert_indices((4, 5))\njulia> println(order)\n[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(2, 2), ...]\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._gilbert_order-Tuple{AbstractMatrix}","page":"Developers API Reference","title":"GraphLab._gilbert_order","text":"_gilbert_order(grid_indices::AbstractMatrix; maj_axis=rows ≥ cols ? 1 : 2)\n\nReturn a list of CartesianIndex values from a grid, traversed recursively using Gilbert curve logic. When maj_axis == 2, the grid is transposed to preserve logic.\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._morton_index-Tuple{Int64, Int64}","page":"Developers API Reference","title":"GraphLab._morton_index","text":"_morton_index(x::Int, y::Int)\n\nInterleave the bits of x and y to produce a Morton code (Z-order curve).\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._morton_indices-Tuple{Tuple{Int64, Int64}}","page":"Developers API Reference","title":"GraphLab._morton_indices","text":"_morton_indices(grid_dims::Tuple{Int, Int})\n\nReturn a list of CartesianIndex{2} grid coordinates ordered by 2D Morton (Z-order) curve.\n\nArguments\n\ngrid_dims::Tuple{Int, Int}: the number of rows and columns of the grid, e.g. (64, 64).\n\nReturns\n\nA vector of CartesianIndex{2} objects representing the traversal order.\n\nExample\n\njulia> order = _morton_indices((4, 4))\njulia> println(order)\n[CartesianIndex(1, 1), CartesianIndex(1, 2), CartesianIndex(2, 1), CartesianIndex(2, 2), ...]\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._nested_dissection-Tuple{SparseArrays.SparseMatrixCSC, Function}","page":"Developers API Reference","title":"GraphLab._nested_dissection","text":"_nested_dissection(A::SparseMatrixCSC, method::Function; coords=nothing, minsep, verbose)\n\nRecursively computes a nested dissection ordering of a sparse matrix, handling disconnected components separately.\n\nArguments\n\nA::SparseMatrixCSC: The adjacency matrix of the graph to partition.\nmethod::Function: Function used to compute separators.\ncoords::Union{Matrix, Nothing}: Optional node coordinates if the separator method needs them.\nminsep::Int: Minimum number of nodes to stop recursion.\nverbose::Bool: Whether to visualize partitions and wait for user input during recursion.\n\nReturns\n\nperm::Vector{Int}: The final permutation vector.\n\nNotes\n\nUses approximate minimum degree ordering for small components.\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._opposite_dir-Tuple{Symbol}","page":"Developers API Reference","title":"GraphLab._opposite_dir","text":"_opposite_dir(dir::Symbol)::Symbol\n\nReturn the opposite direction symbol.\n\nArguments\n\ndir::Symbol: Direction symbol (:L, :R, :T, or :B).\n\nReturns\n\nThe opposite direction symbol.\n\nExample\n\njulia> _opposite_dir(:L)\n:R\njulia> _opposite_dir(:T)\n:B\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._order_type-Tuple{Symbol, Symbol}","page":"Developers API Reference","title":"GraphLab._order_type","text":"_order_type(entry::Symbol, exit::Symbol)\n\nDetermine the traversal type based on entry and exit directions.\n\nArguments\n\nentry::Symbol: Entry direction (:L, :R, :T, or :B).\nexit::Symbol: Exit direction (:L, :R, :T, or :B).\n\nReturns\n\n:tran if entry and exit are opposite directions.\n:cis otherwise.\n\nExample\n\njulia> _order_type(:L, :R)\n:tran\njulia> _order_type(:T, :R)\n:cis\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._part1by1-Tuple{Int64}","page":"Developers API Reference","title":"GraphLab._part1by1","text":"_part1by1(n::Int)\n\nExpand 16-bit integer n into 32 bits with zeros between the original bits.\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._partition-Tuple{Matrix, Vector}","page":"Developers API Reference","title":"GraphLab._partition","text":"_partition(coords::Matrix, v::Vector)\n\nCompute a partition based on coords using a direction vector v.\n\nArguments\n\ncoords::Matrix: Node coordinates in a 2D space.\nv::Vector: Direction vector defining the partitioning line.\n\nReturns\n\nA tuple of two vectors: indices of nodes in each partition.\n\nExample\n\njulia> _partition(coords, [0, 1])\n([1, 2, 3, 9, 10], [4, 5, 6, 7, 8])\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._partition-Tuple{Matrix{Float64}, Vector{Float64}}","page":"Developers API Reference","title":"GraphLab._partition","text":"_partition(X, direction)\n\nSplits a set of points into two parts by projecting them onto a given direction vector and _partitioning at the median projection value.\n\nArguments\n\nX::Matrix{Float64}: An n × d matrix of points (each row is a point in ℝ^d or ℝ^{d+1}).\ndirection::Vector{Float64}: A direction vector along which to project the points.\n\nReturns\n\npart1::Vector{Int}: Indices of points with projection ≤ median (one side of the cut).\npart2::Vector{Int}: Indices of points with projection > median (the other side).\n\nNotes\n\nThis ensures a balanced _partition by cutting at the median of the projected values.\nCommonly used to implement great-circle or hyperplane separators.\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._recursive_bisection","page":"Developers API Reference","title":"GraphLab._recursive_bisection","text":"_recursive_bisection(method::Function, levels::Int, A::AbstractSparseMatrix, \n                     coords::Union{Matrix, Nothing}=nothing, minpoints::Int=8, \n                     vn::Vector{Int}=Int[])\n\nRecursively partition the graph A using the given partitioning method, applying hierarchical bisection.\n\nArguments\n\nmethod::Function: Partitioning method to apply (e.g., part_spectral, part_inertial).\nlevels::Int: Number of recursive partitioning levels.\nA::AbstractSparseMatrix: Adjacency matrix of the graph.\ncoords::Union{Matrix, Nothing}=nothing: Node coordinates for spatial partitioning (if applicable).\nminpoints::Int=8: Minimum number of nodes required to continue partitioning.\nvn::Vector{Int}=Int[]: Vector of node indices, used for tracking original node ordering.\n\nReturns\n\nA vector of partition labels for each node, recursively refined through hierarchical bisection.\n\nExample\n\njulia-repl julia> _recursive_bisection(part_spectral, 3, A, coords)  1  ⋮  4\n\n\n\n\n\n","category":"function"},{"location":"dev_api/#GraphLab._reflector-Tuple{Any}","page":"Developers API Reference","title":"GraphLab._reflector","text":"_reflector(c::AbstractVector)\n\nConstructs a Householder reflection matrix Q that maps the input vector c (reversed) to a multiple of the first basis vector. This is useful for aligning a given direction with a coordinate axis in geometric transformations.\n\nArguments\n\nc::AbstractVector: A real vector of length d.\n\nReturns\n\nQ::Matrix{Float64}: A d × d orthogonal matrix representing the Householder reflection.\nr::Float64: The leading entry of the reflected vector (i.e., norm or signed component).\n\nNotes\n\nInternally, this performs a QR decomposition of the reversed vector c[end:-1:1] and adjusts the result to restore the original ordering.\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._sepcircle-Tuple{SparseArrays.SparseMatrixCSC, Matrix{Float64}, Int64}","page":"Developers API Reference","title":"GraphLab._sepcircle","text":"_sepcircle(A::SparseMatrixCSC, X::Matrix{Float64}, ntrials::Int)\n\nTry ntrials random great circle cuts on unit-sphere data.\n\nArguments:\n\nA::SparseMatrixCSC: adjacency matrix\nX::Matrix{Float64}: n × (d+1) unit-sphere coordinates\nntrials::Int: number of random directions to try\n\nReturns:\n\nbestdir::Vector{Float64}: direction vector of best cut\nmincut::Float64: minimum edge cut found\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._sepline-Tuple{SparseArrays.SparseMatrixCSC, Matrix{Float64}, Int64}","page":"Developers API Reference","title":"GraphLab._sepline","text":"_sepline(A, xy, ntrials)\n\nTry ntrials random straight hyperplanes in Euclidean space.\n\nArguments:\n\nA::SparseMatrixCSC: adjacency matrix\ncoords::Matrix{Float64}: n × d original coordinates\nntrials::Int: number of directions to try\n\nReturns:\n\nbestdir::Vector{Float64}: best direction\nmincut::Float64: corresponding edge cut\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._sepquality-Tuple{Vector{Float64}, SparseArrays.SparseMatrixCSC, Matrix{Float64}}","page":"Developers API Reference","title":"GraphLab._sepquality","text":"_sepquality(v, A, xyz)\n\nEvaluates the quality of a geometric separator defined by a direction vector v, by computing the number of graph edges cut by the resulting _partition.\n\nArguments\n\nv::Vector{Float64}: A direction vector defining the separating hyperplane (e.g., great circle).\nA::SparseMatrixCSC: The adjacency matrix of the (undirected) graph.\nxyz::Matrix{Float64}: An n × (d+1) matrix of vertex coordinates on the unit sphere (in ℝ^{d+1}).\n\nReturns\n\ncutsize::Int: The number of edges crossing between the two sides of the _partition.\n\nNotes\n\nVertices are _partitioned based on the sign of their projection onto v.\nThe number of crossing edges is computed using nonzero entries in A[a, b] and A[b, a]'.\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._split-Tuple{Matrix{Float64}, Int64}","page":"Developers API Reference","title":"GraphLab._split","text":"_split(coords::Matrix{Float64}, dim::Int)\n\n_split a set of 2D points along a specified dimension at the median.\n\nArguments\n\ncoords::Matrix{Float64}: A matrix of size n × 2, where each row is a 2D point (x, y).\ndim::Int: _splitting dimension (1 for x-axis, 2 for y-axis).\n\nReturns\n\nleft::Matrix{Float64}: Points in the left subset (≤ _split value).\nright::Matrix{Float64}: Points in the right subset (> _split value).\n_splitval::Float64: The coordinate value at which the _split occurs.\n\nExample\n\njulia> left, right, _splitval = _split([1.0 2.0; 3.0 4.0; 0.0 5.0], 1)\n([0.0 5.0; 1.0 2.0], [3.0 4.0], 1.0)\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._step-Tuple{Symbol, Symbol, Int64, Tuple{Float64, Float64}, Float64}","page":"Developers API Reference","title":"GraphLab._step","text":"_step(entry::Symbol, exit::Symbol, _splitdim::Int, entry_pt::Tuple{Float64, Float64}, _splitval::Float64)\n\nDetermine the traversal order of child nodes in a kd-tree based on entry and exit directions.\n\nArguments\n\nentry::Symbol: Entry direction (:L, :R, :T, or :B).\nexit::Symbol: Exit direction (:L, :R, :T, or :B).\n_splitdim::Int: _splitting dimension (1 for x-axis, 2 for y-axis).\nentry_pt::Tuple{Float64, Float64}: Coordinates of the entry point.\n_splitval::Float64: Value of the splitting plane along `splitdim`.\n\nReturns\n\nA vector of symbols indicating the traversal order of child nodes (e.g., [:left, :right]).\n\nExample\n\njulia> _step(:L, :R, 1, (0.0, 0.5), 0.3)\n[:left, :right]\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._stereodown-Tuple{Any}","page":"Developers API Reference","title":"GraphLab._stereodown","text":"_stereodown(xyz::AbstractMatrix)\n\nPerforms the inverse of stereographic projection, mapping points from the unit sphere in ℝ^{d} (embedded in ℝ^{d+1}) back to Euclidean space ℝ^{d}.\n\nArguments\n\nxyz::AbstractMatrix: An n × (d + 1) matrix where each row is a point on the unit sphere in ℝ^d.\n\nReturns\n\nxy::Matrix{Float64}: An n × d matrix of projected points in Euclidean space.\n\nNotes\n\nAssumes the last coordinate in each row of xyz corresponds to the vertical axis (pole).\nThis operation is the inverse of the stereographic projection performed in _stereoup.\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._stereoup-Tuple{Matrix{Float64}}","page":"Developers API Reference","title":"GraphLab._stereoup","text":"Stereographically lift points to the unit sphere in (d+1)-dimensional space.\n\ncoords: n × d matrix of points Returns: n × (d+1) matrix on the unit sphere\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._traverse_kd","page":"Developers API Reference","title":"GraphLab._traverse_kd","text":"_traverse_kd(node::KdNode, entry::Symbol=:L, exit::Symbol=:R, last_exits::Vector{Any}=[], acc::Vector{Any}=[])\n\nTraverse a kd-tree following an adaptive space-filling curve and collect leaf data.\n\nThis function recursively traverses a kd-tree according to entry and exit directions, determining the order of child traversal at each node using adaptive rules. At each leaf node, it collects the stored data into an accumulator.\n\nArguments\n\nnode::KdNode: The kd-tree node to traverse.\nentry::Symbol=:L: Entry direction (:L, :R, :T, :B) at the current node.\nexit::Symbol=:R: Exit direction at the current node.\nlast_exits::Vector{Any}=[]: List of exit points accumulated during traversal.\nacc::Vector{Any}=[]: Accumulator for collected leaf data.\n\nReturns\n\nIf node.is_root, returns acc, the accumulated leaf data in traversal order.\nOtherwise returns the last exit point from the traversal.\n\nExample\n\njulia> data = _traverse_kd(tree)\n[[x1, y1, id1], [x2, y2, id2], ...]\n\n\n\n\n\n","category":"function"},{"location":"dev_api/#GraphLab._vis_graph-Tuple{SparseArrays.SparseMatrixCSC, Matrix, Vector{Int64}}","page":"Developers API Reference","title":"GraphLab._vis_graph","text":"_vis_graph(A::SparseMatrixCSC, coords::Matrix, p::Vector{Int})\n\nVisualize the partitioning p of graph A using node coordinates coords.\n\nArguments\n\nA: Adjacency matrix of the graph.\ncoords: Node coordinates for plotting.\np: Partition labels for each node.\n\nOutput\n\nDisplays the partitioned graph visualization.\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab._vtxsep-NTuple{4, Any}","page":"Developers API Reference","title":"GraphLab._vtxsep","text":"_vtxsep(gborder, p1border, p2border, match)\n\nComputes a vertex separator based on alternating paths in a bipartite border graph.\n\nArguments\n\ngborder::Graph: Bipartite graph between border nodes.\np1border::Vector{Int}: Border nodes from partition 1.\np2border::Vector{Int}: Border nodes from partition 2.\nmatch: Maximum matching result on gborder.\n\nReturns\n\n(sep, new_p1border, new_p2border): \nsep: Separator set of vertices.\nnew_p1border: Updated partition 1 border after separator removal.\nnew_p2border: Updated partition 2 border after separator removal.\n\nNotes\n\nTraverses alternating paths between matching and non-matching edges to construct the separator.\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab.grid_graph-Tuple{Int64, Int64, Float64}","page":"Developers API Reference","title":"GraphLab.grid_graph","text":"grid_graph(n::Int, m::Int, α::Float64)\n\nReturns the adjacency matrix A::SparseMatrixCSC and the coordinates coords::Matrix{Float64} of an n × m grid graph rotated by angle α (in radians).\n\nVertices are ordered row-wise: vertex i,j has index (i-1)*m + j.\n\n\n\n\n\n","category":"method"},{"location":"dev_api/#GraphLab.wait_for_key-Tuple{Any}","page":"Developers API Reference","title":"GraphLab.wait_for_key","text":"wait_for_key(prompt)\n\nPrints a prompt to the standard output and waits for a single keypress from the user.\n\nArguments\n\nprompt::String: The message to display before waiting for input.\n\nReturns\n\nnothing.\n\n\n\n\n\n","category":"method"}]
}
